# 第9章 内存模型和名称空间

## 本章内容

+ 单独编译

+ 存储持续性、作用域和链接性

+ 定位（placement)new 运算符

+ 名称空间

C++ 为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存，而定位new运算符提供了这种技术的一类变种。C++名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。

## 单独编译

1. C++允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独编译这些文件，然后将它们链接成可执行的程序。（通常C++编译器既编译程序，也管理链接器）。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其它文件的编译版本链接。这使得大程序的管理更便捷。

2. 大多数C++环境都提供了其他工具来帮助管理。

3. 提供#include处理：与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构声明时，只需要在头文件中做一次改动即可。也可以将函数原型放在头文件中

4. 程序分为三部分：
   
   + 头文件：包含结构声明和使用这些结构的函数的原型
   
   + 源代码文件：包含与结构有关的函数的代码
   
   + 源代码文件：包含调用与结构相关的函数的代码

5. 这是一种非常有用的组织程序的策略。例如，如果编写另一个程序时，也需要使用这些函数，则只需包含头文件，并将函数文件添加到项目列表或make列表中即可。另外这种组织方式也与OOP方法一致。

6. 一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操纵用户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中。

7. 请不要将函数定义或变量声明放到头文件中，对于简单情况可行，但通常会引来麻烦。例如，如果在头文件包含一个函数定义，然后在其他两个文件（属于同一个程序）中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数时内联的，否则将出错。

8. 头文件中常包含的内容：
   
   + 函数原型
   
   + 使用#define或const定义的符号常量
   
   + 结构声明（不创建变量，告诉编译器如何创建该结构变量）
   
   + 类声明
   
   + 模板声明（指示编译器如何生成与源代码中的函数调用相匹配的函数定义）
   
   + 内联函数（const和内联函数有特殊的链接属性）

9. 如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。如果没有在那里找到头文件，则将在标准位置查找

> ### 头文件管理
> 
> 在同一个文件中只能将同一个头文件包含一次。很可能在不知情的情况下将头文件包含多次。
> 
> 基于预处理器编译指令 **#ifndef** (即if not defined)的。下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#ifndef 和 # endif之间的语句：
> 
> ```cpp
> #ifndef COORDIN_H_
> #define COORDIN_H_  // 使用#define语句创建符号常量，将文件内容包含
> // place include file contents here
> #endif
> 
> ```
