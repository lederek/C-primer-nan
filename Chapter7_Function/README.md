# 第七章    函数——C++的编程模块

## 本章内容：

+ 函数基本知识

+ 函数原型

+ 按值传递函数参数

+ 设计处理数组的函数

+ 使用const指针参数

+ 设计处理文本字符串的函数

+ 设计处理结构的函数

+ 设计处理string对象的函数

+ 调用自身的函数（递归）

+ 指向函数的指针



## 复习函数的基本知识

1. 要使用C++函数，必须完成如下工作：
   
   + 提供函数定义
   
   + 提供函数原型
   
   + 调用函数

2. 库函数是已经定义和编译好的函数，同时可以使用标准头文件提供其原型， 只需正确地调用这种函数即可。

### 定义函数

1. 分成两类：没有返回值的函数和有返回值的函数。
   
   1. 没有返回值的函数被称为**void**函数，其通用格式如下：
      
      ```C++
      void functionName(parameterList)
      {
          statements(s)
          return;        // optional
      }
      ```
      
      *parameterList* 指定了传递给函数的参数类型和数量，可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。
   
   2. 有返回值的函数将生成一个值，并将它返回给调用函数。函数的类型被声明为返回值得类型，其通用格式如下：
      
      ```C++
      typeName functionName(parameterList)
      {
          statement(s)
          return value;    // value is type cast to type typeName
      }
      ```
      
      + 对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量、表达式， 只是其结果的类型必须为typeName类型或可以被转换为typeName, 然后，函数将最终的值返回给调用函数。
      
      + C++对于返回值类型的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针、结构和对象
      
      + 函数将在执行返回语句后结束。若函数包含多条返回语句，则函数在执行遇到的第一条返回语句后结束
        
        
        
        

### 函数原型和函数调用

1. 为什么需要原型
   
   + 原型描述了函数到编译器的借口，即将函数返回值的类型以及参数的类型和数量告诉编译器。
   
   + C++允许将一个程序放在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情况下，编译器在编译main()时，可能无权访问函数代码
   
   + 避免使用函数原型的唯一方法：在首次使用函数之前定义它

2. 原型的语法
   
   + 函数原型是一条语句，因此必须以分号结束。
   
   + 获取原型最简单的方法：复制函数定义中的函数头，并添加分号。函数原型不要求参数列表，可以包括变量名，也可以不包括。
   
   + 原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。
   
   > C++原型与ANSI原型
   > 
   > ANSI C借鉴了C++中的原型，区别如下：
   > 
   > + ANSI C中的原型是可选的，但在C++ 中，原型必不可少
   > 
   > + 在C++ 中，括号为空与在括号中使用关键字**void** 是等效的——意味着函数没有函数
   > 
   > + 在ANSI C中，括号为空意味着不指出参数——这意味着将在后面定义参数列表
   > 
   > + 在C++ 中，不指定参数列表时应使用省略号：
   >   
   >   通常，仅当与接受可变参数的C函数（如printf()）交互时才需要这样做
   >   
   >   ```C++
   >   void say_bye(...);      // C++ abdication of responsibility
   >   ```

3.  原型的功能
   
   它们可以极大地降低程序出错的几率。具体来说，
   
   + 编译器正确处理函数返回值；
   
   + 编译器检查使用的参数数目是否正确；
   
   + 编译器检查使用的参数类型是否正确。不正确则转换为正确的类型
   
   在编译阶段进行的原型化被称为静态类型检查（static type checking)。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。
